{"version":3,"sources":["reviewSchema.js"],"names":["mongoose","require","Tour","reviewSchema","Schema","review","required","type","Number","rating","max","Date","createdAt","now","user","Types","ObjectId","ref","toJSON","virtuals","index","tour","unique","pre","next","this","populate","path","select","calcAverageRatings","tourId","stats","regeneratorRuntime","async","_context","prev","awrap","aggregate","$match","$group","statics","nRating","$sum","avgRating","$avg","sent","length","ratingsAverage","_id","stop","post","_context2","constructor","_context3","doc","_context4","model","ratingsQuantity","module","exports","Review"],"mappings":"aACA,IAAMA,SAAWC,QAAQ,YADzBC,KAAAD,QAAA,gBAIME,aAAeH,SAASI,OAF9B,CAIIC,OAAQ,CAFNF,KAAAA,OAEFE,SAAQ,EAAA,EAAA,6BAENC,OAAQ,CAHZC,KAAAC,OAKEC,IAAQ,EACNF,IAAMC,GAENE,UAAK,CARTH,KAAAI,KAUEC,QAAWD,KAAAE,KAETC,KAAA,CAZJP,KAAAP,SAAAI,OAAAW,MAAAC,SAcMC,IAAE,OACJV,SAAMP,EAAAA,EAASI,kCAEfE,KAAAA,CAjBJC,KAAAP,SAAAI,OAAAW,MAAAC,SAmBMC,IAAE,OACJV,SAAMP,EAAAA,EAASI,mCADX,CAMRc,OAAA,CAAAC,UAAA,GACED,SAAQ,CAAAC,UAAA,KACIA,aAAQC,MAAE,CAAAC,KAAA,EAAAP,KAAA,GAAA,CAAAQ,QAAA,IAFxBnB,aA1BFoB,IAAA,QAAA,SAAAC,GAmCEC,KAAAC,SAAA,CACAC,KAAA,OACAC,OAAA,eAGAJ,MAEArB,aAAKuB,QAASG,mBAAA,SAAAC,GAAA,IAAAC,EAAA,OAAAC,mBAAAC,MAAA,SAAAC,GAAA,OAAA,OAAAA,EAAAC,KAAAD,EAAAV,MAAA,KAAA,EAAA,OAAAU,EAAAV,KAAA,EAAAQ,mBAAAI,MAAAX,KAAAY,UAAA,CAEZT,CAFFU,OAAA,CAAAjB,KAAAS,IARF,CAqBMS,OAAQ,CANdpC,IAAaqC,QAA6BC,QAAA,CAAAC,KAAA,GAAAC,UAAA,CAAAC,KAAA,gBAP1B,KAAA,EAAA,GAO0B,GANlCb,EADQG,EAAAW,MAO0BC,OAP1B,OAAAZ,EAAAV,KAAA,EAAAQ,mBAAAI,MAUVE,KAAAA,kBAAQR,EAAA,CAAET,gBAAMS,EAAAA,GAAAA,QAARiB,eAAAhB,EAAA,GAAAU,WAVEP,EAAAV,KAAA,EAAA,MAAA,KAAA,EAAAU,EAAAV,KAAA,GAAA,MAAA,KAAA,EAAA,OAAAU,EAAAV,KAAA,GAAAQ,mBAAAI,MAcRY,KAAAA,kBADMlB,EAAA,CAENW,gBAAS,EAAEC,eAAM,OAfT,KAAA,GAAA,IAAA,MAAA,OAAAR,EAAAe,SAAA,KAAAxB,OAaFtB,aAAA+C,KAAA,OAAA,WAAA,OAAAlB,mBAAAC,MAAA,SAAAkB,GAAA,OAAA,OAAAA,EAAAhB,KAAAgB,EAAA3B,MAAA,KAAA,EAAA,OAAA2B,EAAA3B,KAAA,EAAAQ,mBAAAI,MAuBNX,KAAK2B,YAAYvB,mBAAmBJ,KAAKJ,OAvBnC,KAAA,EAAA,IAAA,MAAA,OAAA8B,EAAAF,SAAA,KAAAxB,QA0BdtB,aAAaoB,IAAI,cAAe,SAAgBC,GAAhB,OAAAQ,mBAAAC,MAAA,SAAAoB,GAAA,OAAA,OAAAA,EAAAlB,KAAAkB,EAAA7B,MAAA,KAAA,EAhCUA,IAgCV,KAAA,EAAA,IAAA,MAAA,OAAA6B,EAAAJ,YAhCU9C,aAAA+C,KAAA,cAAA,SAAAI,GAAA,OAAAtB,mBAAAC,MAAA,SAAAsB,GAAA,OAAA,OAAAA,EAAApB,KAAAoB,EAAA/B,MAAA,KAAA,EAAA,OAAA+B,EAAA/B,KAAA,EAAAQ,mBAAAI,MAqClCX,KAAK+B,MAAM3B,mBAAmByB,EAAIjC,OArCA,KAAA,EAAA,IAAA,MAAA,OAAAkC,EAAAN,SAAA,KAAAxB,QAgBpCgC,IAAAA,OAAAA,SAAAA,MAAiB1B,SAASU,cADSiB,OAAAC,QAfCC","file":"reviewSchema.min.js","sourcesContent":["// review / rating / createAt / ref to tour / ref to user\r\nconst mongoose = require(\"mongoose\");\r\nconst Tour = require(\"./tourSchema\");\r\n\r\nconst reviewSchema = mongoose.Schema(\r\n  {\r\n    review: {\r\n      type: String,\r\n      required: [true, \"Review can not be empty!\"],\r\n    },\r\n    rating: {\r\n      type: Number,\r\n      min: 1,\r\n      max: 5,\r\n    },\r\n    createdAt: {\r\n      type: Date,\r\n      default: Date.now,\r\n    },\r\n    user: {\r\n      type: mongoose.Schema.Types.ObjectId,\r\n      ref: \"User\",\r\n      required: [true, \"Review must belong to a User.\"],\r\n    },\r\n    tour: {\r\n      type: mongoose.Schema.Types.ObjectId,\r\n      ref: \"Tour\",\r\n      required: [true, \"Review must belong to a tour.\"],\r\n    },\r\n  },\r\n  {\r\n    toJSON: { virtuals: true },\r\n    toObject: { virtuals: true },\r\n  },\r\n);\r\n\r\nreviewSchema.index({ tour: 1, user: 1 }, { unique: true });\r\n\r\nreviewSchema.pre(/^find/, function (next) {\r\n  // this.populate({\r\n  //   path: \"tour\",\r\n  //   select: \"name\",\r\n  // }).populate({\r\n  //   path: \"user\",\r\n  //   select: \"name photo\",\r\n  // });\r\n  this.populate({\r\n    path: \"user\",\r\n    select: \"name photo\",\r\n  });\r\n\r\n  next();\r\n});\r\nreviewSchema.statics.calcAverageRatings = async function (tourId) {\r\n  const stats = await this.aggregate([\r\n    {\r\n      $match: { tour: tourId },\r\n    },\r\n    {\r\n      $group: {\r\n        _id: \"$tour\",\r\n        nRating: { $sum: 1 },\r\n        avgRating: { $avg: \"$rating\" },\r\n      },\r\n    },\r\n  ]);\r\n\r\n  if (stats.length > 0) {\r\n    await Tour.findByIdAndUpdate(tourId, {\r\n      ratingsQuantity: stats[0].nRating,\r\n      ratingsAverage: stats[0].nRating,\r\n    });\r\n  } else {\r\n    await Tour.findByIdAndUpdate(tourId, {\r\n      ratingsQuantity: 0,\r\n      ratingsAverage: 4.5,\r\n    });\r\n  }\r\n};\r\n\r\nreviewSchema.post(\"save\", async function () {\r\n  // This points to current review\r\n  await this.constructor.calcAverageRatings(this.tour);\r\n});\r\n\r\nreviewSchema.pre(/^findOneAnd/, async function (next) {\r\n  next();\r\n});\r\n\r\nreviewSchema.post(/^findOneAnd/, async function (doc) {\r\n  await this.model.calcAverageRatings(doc.tour);\r\n});\r\n\r\nconst Review = mongoose.model(\"Review\", reviewSchema);\r\n\r\nmodule.exports = Review;\r\n"]}